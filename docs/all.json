{"shell":true,"revision":"f489cabde2ffc9066c73940d9be33d284f38b43b","objects":[{"type":null,"source":"lib/numbers.ex:5","object_type":"ModuleObject","moduledoc":"Allows you to perform math on any kind of data structure that follows the Numeric behaviour.\n\nThis includes plain Integer and Floats, but also many custom numeric types specified in packages\n(such as Ratio, Decimal, Tensor, ComplexNum).\n\n","module":"Elixir.Numbers","id":"Numbers"},{"type":"exception","source":"lib/numbers.ex:14","object_type":"ModuleObject","moduledoc":"Raised when add/2, sub/2, mult/2 or div/2 is called with two different kinds of structs as arguments.\n","module":"Elixir.Numbers.AmbiguousOperandsError","id":"Numbers.AmbiguousOperandsError"},{"type":"exception","source":"lib/numbers.ex:84","object_type":"ModuleObject","moduledoc":"Raised by `coerce/2` when coercion is not possible.\n","module":"Elixir.Numbers.CannotCoerceError","id":"Numbers.CannotCoerceError"},{"type":"exception","source":"lib/numbers.ex:130","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Numbers.CannotConvertToFloatError","id":"Numbers.CannotConvertToFloatError"},{"type":null,"source":"lib/numeric.ex:2","object_type":"ModuleObject","moduledoc":"Any module that wants to be a Numeric type,\nand to be able to be called by the functions in Number,\nshould make sure that this behaviour is followed.\n\nYour callbacks will only ever be called with two versions of your Numeric struct.\nIf one of the functions in Number is called with one of the arguments being an integer or float,\nthen it is first converted to your Numeric struct by calling `YourStructModule.new(the_int_or_float)` on it.\n","module":"Elixir.Numeric","id":"Numeric"},{"type":"def","source":"lib/numbers.ex:124","signature":[["num",[],null]],"object_type":"FunctionObject","name":"abs","module_id":"Numbers","id":"abs/1","doc":"Computes the absolute value of `num`.\n","arity":1},{"type":"def","source":"lib/numbers.ex:22","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"add","module_id":"Numbers","id":"add/2","doc":"Adds two Numeric `a` and `b` together.\n\n## Example:\n\niex> Numbers.add(1, 2)\niex> Numbers.add(10.0, 123)\n","arity":2},{"type":"def","source":"lib/numbers.ex:90","signature":[["numericType",[],null],["num",[],null]],"object_type":"FunctionObject","name":"coerce","module_id":"Numbers","id":"coerce/2","doc":"Attempts to coerce a built-in datatype `num` to a struct of type `numericType`\nby calling `numericType.new(num)`.\n\nThis function will raise an `CannotCoerceError` if:\n\n- There is no `numericType.new/1` function available.\n- The function is available but returns an ArgumentError for the passed built-in data type.\n\n","arity":2},{"type":"def","source":"lib/numbers.ex:47","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"div","module_id":"Numbers","id":"div/2","doc":"Divides the Numeric `a` by `b`.\n\nNote that this is a supposed to be a full (non-truncated) division;\nno rounding or truncation is supposed to happen, even when calculating with integers.\n","arity":2},{"type":"def","source":"lib/numbers.ex:118","signature":[["num",[],null]],"object_type":"FunctionObject","name":"minus","module_id":"Numbers","id":"minus/1","doc":"Computes the unary minus of `num`, also known as its negation.\n","arity":1},{"type":"def","source":"lib/numbers.ex:42","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"mult","module_id":"Numbers","id":"mult/2","doc":"Multiplies the Numeric `a` with the Numeric `b`\n","arity":2},{"type":"def","source":"lib/numbers.ex:155","signature":[["base",[],null],["exponent",[],null]],"object_type":"FunctionObject","name":"pow","module_id":"Numbers","id":"pow/2","doc":"Power function: computes `base^exponent`,\nwhere `base` is Numeric,\nand `exponent` _has_ to be an integer.\n\nThis means that it is impossible to calculate roots by using this function.\n\nIf `base` supports direct computation of `pow`, that is used. Otherwise,\nthe Exponentiation by Squaring algorithm is used.\n","arity":2},{"type":"def","source":"lib/numbers.ex:32","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"sub","module_id":"Numbers","id":"sub/2","doc":"Subtracts the Numeric `b` from the Numeric `a`.\n\n## Example:\n\niex> Numbers.sub(1, 2)\niex> Numbers.sub(10.0, 123)\n","arity":2},{"type":"def","source":"lib/numbers.ex:137","signature":[["num",[],null]],"object_type":"FunctionObject","name":"to_float","module_id":"Numbers","id":"to_float/1","doc":"Tries to convert `num` to a built-in floating-point number.\n\nNote that precision might be lost during this conversion.\n\nNot all numeric data types support this conversion!\nA `CannotConvertToFloatError` is raised if this conversion is unsupported by the passed data type.\n","arity":1},{"type":"def","source":"lib/numbers.ex:17","signature":[["msg",[],null]],"object_type":"FunctionObject","name":"exception","module_id":"Numbers.AmbiguousOperandsError","id":"exception/1","doc":false,"arity":1},{"type":"def","source":"lib/numbers.ex:17","signature":[["exception",[],null]],"object_type":"FunctionObject","name":"message","module_id":"Numbers.AmbiguousOperandsError","id":"message/1","doc":false,"arity":1},{"type":"def","source":"lib/numbers.ex:87","signature":[["msg",[],null]],"object_type":"FunctionObject","name":"exception","module_id":"Numbers.CannotCoerceError","id":"exception/1","doc":false,"arity":1},{"type":"def","source":"lib/numbers.ex:87","signature":[["exception",[],null]],"object_type":"FunctionObject","name":"message","module_id":"Numbers.CannotCoerceError","id":"message/1","doc":false,"arity":1},{"type":"def","source":"lib/numbers.ex:131","signature":[],"object_type":"FunctionObject","name":"__struct__","module_id":"Numbers.CannotConvertToFloatError","id":"__struct__/0","doc":"Raised by `to_float/1` when (lossy) conversion to float is not possible.\n","arity":0},{"type":"def","source":"lib/numbers.ex:134","signature":[["msg",[],null]],"object_type":"FunctionObject","name":"exception","module_id":"Numbers.CannotConvertToFloatError","id":"exception/1","doc":false,"arity":1},{"type":"def","source":"lib/numbers.ex:134","signature":[["exception",[],null]],"object_type":"FunctionObject","name":"message","module_id":"Numbers.CannotConvertToFloatError","id":"message/1","doc":false,"arity":1}],"language":"elixir","git_repo_url":"https://github.com/Qqwy/elixir_number.git","client_version":"0.5.5","client_name":"inch_ex","branch_name":"master","args":[]}